<?php
if (PHP_VERSION_ID < 50400) {
    echo "You need PHP 5.4+ to execute this script.\n";
    exit(1);
}
if (! class_exists('DOMDocument') || ! class_exists('DOMXPath')) {
    fwrite(STDERR, "The DOM extension must be enabled in order execute this script.\n");
    exit(1);
}
if (! class_exists('XSLTProcessor')) {
    fwrite(STDERR, "The XSL extension must be enabled in order execute this script.\n");
    exit(1);
}
set_error_handler(function ($errno, $errstr, $errfile = '', $errline = null) {
    throw new ErrorException($errstr, $errno, $errno, $errfile, $errline);
});

/**
 * Class that translates XML files (generated with the "extract" command) to PHP stub files.
 */
class StubsGenerator
{

    /**
     * The namespace of the XML file generated by the "extract" command.
     *
     * @var string
     */
    const XML_NAMESPACE = 'http://mlocati.github.io/PIdeExtHelp';

    /**
     * The POSIX OS-specific tag.
     *
     * @var string
     */
    const OSTAG_POSIX = 'posix';

    /**
     * The Windows OS-specific tag.
     *
     * @var string
     */
    const OSTAG_WINDOWS = 'windows';

    use VerboseTrait;

    /**
     * Should we validate the XML file generated by the "extract" command?
     *
     * @var bool
     */
    private $validateXml = true;

    /**
     * Should we write a PHP file for every extension (true) or should we write a single output PHP file (false)?
     *
     * @var string
     */
    private $splitOutput = true;

    /**
     * The path of the XSD schema file.
     *
     * @var string
     */
    private $schemaFile;

    /**
     * The path to the XML file generatde by the "extract" command.
     *
     * @var string
     */
    private $inputXmlPath;

    /**
     * The loaded XML file generated by the "extract" command.
     *
     * @var DOMDocument
     */
    private $inputXml;

    /**
     * The XPath helper associated with the loaded XML file.
     *
     * @var DOMXPath
     */
    private $inputXPath;

    /**
     * The PHP version defined in the input XML file.
     *
     * @var string
     */
    private $inputPhpVersion;

    /**
     * An instance of TypeFormatter
     *
     * @var TypeFormatter
     */
    private $typeFormatter;

    /**
     * The output path.
     *
     * @var string
     */
    private $outputPath;

    /**
     * The current stub writer.
     *
     * @var StubWriter|null
     */
    private $currentWriter;

    /**
     * An instance of the PHPManual class.
     *
     * @var PHPManual
     */
    private $phpManual;

    /**
     * Initialize the instance.
     *
     * @param array $argv
     *            The arguments passed via the command line.
     */
    public function __construct(array $argv)
    {
        $stopOptions = false;
        $docBaseDirectory = null;
        $docDirectory = null;
        $cacheFile = null;
        $useCache = true;
        $rebuildCacheItems = array();
        $valudRebuildCacheItems = array(
            PHPManualCache::ANYKEY,
            PHPManualCache::KEY_XMLENTITIES,
            PHPManualCache::KEY_DOCUMENTIDMAP,
            PHPManualCache::KEY_ITEMS
        );
        array_shift($argv);
        for (;;) {
            $arg = array_shift($argv);
            if ($arg === null) {
                break;
            }
            if ($stopOptions === false) {
                switch (strtolower($arg)) {
                    case '--':
                        $stopOptions = true;
                        continue 2;
                    case '-h':
                    case '--help':
                        self::exitWithHelp(0);
                    case '-v':
                    case '--verbose':
                        $this->verbose = true;
                        continue 2;
                    case '--no-validate':
                        $this->validateXml = false;
                        continue 2;
                    case '--schema':
                        $this->schemaFile = array_shift($argv);
                        if ($this->schemaFile === null) {
                            self::exitWithHelp(1);
                        }
                        if (! is_file($this->schemaFile)) {
                            throw new UserMessageException("Unable to find the specified XSD schema file {$this->schemaFile}");
                        }
                        continue 2;
                    case '--no-split':
                        $this->splitOutput = false;
                        continue 2;
                    case '--output':
                        $this->outputPath = array_shift($argv);
                        if ($this->outputPath === null) {
                            self::exitWithHelp(1);
                        }
                        continue 2;
                    case '--no-cache':
                        $useCache = false;
                        continue 2;
                    case '--rebuild-cache':
                        $cacheKey = array_shift($argv);
                        if ($cacheKey === null) {
                            self::exitWithHelp(1);
                        }
                        $cacheKeys = explode(',', $cacheKey);
                        foreach ($cacheKeys as $cacheKey) {
                            if (! in_array($cacheKey, array(
                                PHPManualCache::ANYKEY,
                                PHPManualCache::KEY_XMLENTITIES,
                                PHPManualCache::KEY_DOCUMENTIDMAP,
                                PHPManualCache::KEY_ITEMS
                            ), true)) {
                                throw new UserMessageException("Unrecognized cache key: {$cacheKey}\nValid values are:\n  " . implode("\n  ", $valudRebuildCacheItems));
                            }
                            $rebuildCacheItems[] = $cacheKey;
                        }
                        continue 2;
                    case '--cache-file':
                        $cacheFile = array_shift($argv);
                        if ($cacheFile === null) {
                            self::exitWithHelp(1);
                        }
                        if (is_dir($cacheFile)) {
                            throw new UserMessageException("The cache file specified points to a directory");
                        }
                        continue 2;
                    default:
                        if ($arg === '' || $arg[0] !== '-') {
                            break;
                        }
                        throw new UserMessageException("Unrecognized option: $arg");
                }
            }
            if ($docBaseDirectory === null) {
                $docBaseDirectory = $arg;
            } elseif ($docDirectory === null) {
                $docDirectory = $arg;
            } elseif ($this->inputXmlPath === null) {
                $this->inputXmlPath = $arg;
            } else {
                self::exitWithHelp(1);
            }
        }
        if ($this->inputXmlPath === null) {
            self::exitWithHelp(1);
        }
        $this->phpManual = new PHPManual($docBaseDirectory, $docDirectory, new PHPManualCache($useCache, $cacheFile === null ? PHPManualCache::getDefaultCacheFile() : $cacheFile, $rebuildCacheItems), $this->verbose);
        $f = realpath($this->inputXmlPath);
        if (! is_file($f)) {
            throw new UserMessageException("Unable to find the input XML file {$this->inputXmlPath}");
        }
        $this->inputXmlPath = str_replace(DIRECTORY_SEPARATOR, '/', $f);
        $loadFlags = 0;
        if (defined('LIBXML_BIGLINES')) {
            $loadFlags |= LIBXML_BIGLINES;
        }
        $this->inputXml = new DOMDocument('1.0', 'UTF-8');
        $this->inputXml->load($this->inputXmlPath, $loadFlags);
        if ($this->validateXml) {
            $schemaFile = $this->schemaFile;
            if ($schemaFile === null) {
                $schemaFile = self::getDefaultSchemaFile();
            }
            if (! is_file($schemaFile)) {
                throw new UserMessageException("Unable to find the XSD schema file {$schemaFile}");
            }
            $xml = $this->inputXml->saveXML();
            $newDocument = new DOMDocument('1.0', 'UTF-8');
            $newDocument->loadXML($xml);
            libxml_clear_errors();
            $prev = libxml_use_internal_errors(true);
            libxml_clear_errors();
            if (! $newDocument->schemaValidate($schemaFile)) {
                $msg = "The file does not conform the XML schema";
                foreach (libxml_get_errors() as $x) {
                    $msg .= "\n" . $x->message . ' (line: ' . $x->line . ')';
                }
                throw new UserMessageException($msg);
            }
            libxml_use_internal_errors($prev);
        }
        $this->inputXPath = new DOMXPath($this->inputXml);
        $this->inputXPath->registerNamespace('ns', self::XML_NAMESPACE);
        $this->inputPhpVersion = $this->inputXml->documentElement->getAttribute('phpVersion');
        if (empty($this->inputPhpVersion)) {
            throw new UserMessageException("{$this->inputXmlPath} does not define a valid PHP version");
        }
        $this->typeFormatter = new TypeFormatter($this->inputPhpVersion);
        if ($this->outputPath === null) {
            $this->outputPath = self::getDefaultOutputPath($this->inputPhpVersion, ! $this->splitOutput);
        }
        if ($this->splitOutput) {
            if (! is_dir($this->outputPath)) {
                throw new UserMessageException("The directory {$this->outputPath} does not exist.");
            }
        } else {
            if (is_dir($this->outputPath)) {
                throw new UserMessageException("The output path {$this->outputPath} already exists and it is a directory.");
            }
        }
    }

    /**
     * Prefetch reference data.
     * This is not mandatory, it's here just for display purposes.
     */
    public function prefetch()
    {
        $this->phpManual->prefetch();
    }

    /**
     * Process the loaded XML file.
     *
     * @throws Exception
     */
    public function process()
    {
        echo "PHP version {$this->inputPhpVersion}\n";
        $extensionElements = $this->inputXPath->query('/ns:schema/ns:extension');
        if ($extensionElements->length < 1) {
            throw new UserMessageException('No extensions found in input XML file.');
        }
        if (! $this->splitOutput) {
            $namespaces = $this->getNamespaces($this->inputXml->documentElement);
            $this->currentWriter = new StubWriter($this->outputPath);
        } else {
            $namespaces = array(
                null
            );
        }
        $error = null;
        try {
            foreach ($namespaces as $namespace) {
                if ($namespace !== null) {
                    $this->currentWriter->startNamespace($namespace, count($namespaces) === 1);
                }
                foreach ($extensionElements as $extensionElement) {
                    $this->writeExtension($extensionElement, $namespace);
                }
                if ($namespace !== null) {
                    $this->currentWriter->endNamespace();
                }
            }
        } catch (Throwable $e) {
            $error = $e;
        } catch (Exception $e) {
            $error = $e;
        }
        if ($error !== null) {
            if ($this->currentWriter) {
                $this->currentWriter->delete();
                $this->currentWriter = null;
            }
            throw $error;
        }
        if (! $this->splitOutput) {
            $this->currentWriter = null;
        }
    }

    /**
     * Get the default path of the XSD schema file to be used to validate the generated XML.
     *
     * @return string
     */
    private static function getDefaultSchemaFile()
    {
        return str_replace(DIRECTORY_SEPARATOR, '/', dirname(dirname(__FILE__))) . '/reference/schema.xsd';
    }

    /**
     * Get the default path of the XSD schema file to be used to validate the generated XML.
     *
     * @param string $phpVersion
     *            The Major-Minor PHP version read from the input XML file.
     * @param bool $asFile
     *            Set to true if you want the path to a PHP file, false for the path of a directory where to store multiple PHP files.
     *            
     * @return string
     */
    private static function getDefaultOutputPath($phpVersion, $asFile)
    {
        return str_replace(DIRECTORY_SEPARATOR, '/', dirname(dirname(__FILE__))) . '/stubs/php' . $phpVersion . ($asFile ? '.php' : '');
    }

    /**
     * Terminates the execution, showing the usage message.
     *
     * @param int $exitCode
     *            The process return code.
     */
    private static function exitWithHelp($exitCode)
    {
        $argv = $_SERVER['argv'];
        $scriptName = $argv[0];
        $defaultSchemaFile = str_replace('/', DIRECTORY_SEPARATOR, self::getDefaultSchemaFile());
        $defaultOutputDirectory = str_replace('/', DIRECTORY_SEPARATOR, self::getDefaultOutputPath('<php-version>', false));
        $defaultOutputFile = str_replace('/', DIRECTORY_SEPARATOR, self::getDefaultOutputPath('<php-version>', true));
        $defaultCacheFile = str_replace('/', DIRECTORY_SEPARATOR, PHPManualCache::getDefaultCacheFile());
        $cacheKey_XmlEntities = PHPManualCache::KEY_XMLENTITIES;
        $cacheKey_DocumentIDMap = PHPManualCache::KEY_DOCUMENTIDMAP;
        $cacheKey_Items = PHPManualCache::KEY_ITEMS;
        $cacheKey_All = PHPManualCache::ANYKEY;
        echo <<<EOF
USAGE: {$scriptName} [-h | --help] [-v | --verbose]
  [--no-validate] [--schema <xsdFile>]
  [--no-split] [--output <output>]
  [--no-cache] [--cache-file <path>]
  [--rebuild-cache <cacheItem> [--rebuild-cache <cacheItem> ...]]
  [--] <docBaseDirectory> <docDirectory> <xmlFile>

Where:
  --help             Show this help.
  --verbose          Verbose output.
  --no-validate      Do not validate the generated XML before saving it.
  --schema           Specify the path to the XSD schema to be used to validate
                     the XML. If not specified we'll assume
                     {$defaultSchemaFile}
  --no-split         Create a single output PHP stub file (if not specified,
                     we'll generate a PHP stub for every extension).
  --output           Specify the output directory (if --no-split is not
                     specified) or the output file (if --no-split is specified).
                     If not specified, we'll assume:
                       if --no-split is not specified:
                         {$defaultOutputDirectory}
                       if --no-split is specified:
                         {$defaultOutputFile}
  --no-cache         Do not use a cache file
  --cache-file       Specify the path to a cache file. If not specified, we'll
                     assume
                     {$defaultCacheFile}
  --rebuild-cache    Rebuild the cache for the specified items.
                     Valid values of <cacheItem> are:
                       $cacheKey_XmlEntities for PHP manual XML entities
                       $cacheKey_DocumentIDMap for PHP manual id map
                       $cacheKey_Items for PHP manual items
                       $cacheKey_All for everything
                     You can specify it multiple times, or use a
                     comma-separated list.
  <docBaseDirectory> The directory that contains a clone of
                     https://svn.php.net/repository/phpdoc/doc-base/trunk
                     or the trunk directory of
                     https://github.com/svn2github/phpdoc_doc-base
  <docDirectory>     The directory that contains a clone of
                     https://svn.php.net/repository/phpdoc/en/trunk
                     or the trunk directory of
                     https://github.com/svn2github/phpdoc_en
  <xmlFile>          The path to a XML file generated by the extract command 
EOF
;
        exit($exitCode);
    }

    /**
     * Get a list of all the namespaces used by child elements of a specific element.
     *
     * @param DOMElement $parentElement
     *
     * @return string[]
     */
    private function getNamespaces(DOMElement $parentElement)
    {
        $namespaces = array();
        $extension = './descendant-or-self::ns:extension';
        foreach ($this->inputXPath->query("({$extension}/ns:constant)|({$extension}/ns:trait)|({$extension}/ns:interface)|({$extension}/ns:class)|({$extension}/ns:function)", $parentElement) as $element) {
            $namespace = $element->getAttribute('namespace');
            if (! in_array($namespace, $namespaces, true)) {
                $namespaces[] = $namespace;
            }
        }
        natcasesort($namespaces);
        return array_values($namespaces);
    }

    /**
     * Process an XML element describing an extension.
     *
     * @param DOMElement $extensionElement
     *            The extension XML element
     * @param string|null $namespace
     */
    private function writeExtension(DOMElement $extensionElement, $containingNamespace)
    {
        $extensionName = $extensionElement->getAttribute('name');
        echo "Processing extension {$extensionName}\n";
        if ($this->splitOutput) {
            $namespaces = $this->getNamespaces($extensionElement);
            $this->currentWriter = new StubWriter($this->outputPath . '/' . $extensionName . '.php');
            $this->currentWriter->writeln('// Start of extension: ' . $extensionName);
            foreach (array(
                self::OSTAG_POSIX,
                self::OSTAG_WINDOWS
            ) as $osTag) {
                $osInfo = $extensionElement->getAttribute('parsedwith-' . $osTag);
                $p = strrpos($osInfo, '@');
                if ($p !== false) {
                    $v = $p === 0 ? '' : substr($osInfo, 0, $p);
                    switch ($osTag) {
                        case self::OSTAG_POSIX:
                            $osTagName = 'POSIX';
                            break;
                        case self::OSTAG_WINDOWS:
                            $osTagName = 'Windows';
                            break;
                        default:
                            $osTagName = $osTag;
                            break;
                    }
                    $this->currentWriter->writeln('// - parsed on ' . $osTagName . ' with PHP ' . substr($osInfo, $p + 1) . ($v === '' ? '' : " (extension version {$v})"));
                }
            }
        } else {
            $namespaces = array(
                null
            );
        }
        foreach ($namespaces as $namespace) {
            if ($namespace === null) {
                $actualNamespace = $containingNamespace;
            } else {
                $this->currentWriter->startNamespace($namespace, count($namespaces) === 1);
                $actualNamespace = $namespace;
            }
            foreach ($extensionElement->childNodes as $childElement) {
                if ($childElement->nodeType === XML_ELEMENT_NODE && $childElement->getAttribute('namespace') === $actualNamespace) {
                    switch ($childElement->nodeName) {
                        case 'iniEntry':
                            break;
                        case 'constant':
                            $this->writeGlobalConstant($extensionElement, $childElement);
                            break;
                        case 'trait':
                            $this->writeTrait($extensionElement, $childElement);
                            break;
                        case 'interface':
                            $this->writeInterface($extensionElement, $childElement);
                            break;
                        case 'class':
                            $this->writeClass($extensionElement, $childElement);
                            break;
                        case 'function':
                            $this->writeGlobalFunction($extensionElement, $childElement);
                            break;
                        default:
                            fwrite(STDERR, 'Unrecognized node name: ' . $childElement->nodeName . "\n");
                            break;
                    }
                }
            }
            if ($namespace !== null) {
                $this->currentWriter->endNamespace();
            }
        }
        if ($this->splitOutput) {
            $this->currentWriter = null;
        }
    }

    private function getOSTagWarning(DOMElement $extensionElement, DOMElement $element)
    {
        $definedForOS = array();
        $undefinedForOS = array();
        foreach (array(
            StubsGenerator::OSTAG_POSIX => 'POSIX',
            StubsGenerator::OSTAG_WINDOWS => 'Windows'
        ) as $osTag => $osName) {
            if ($extensionElement->getAttribute('parsedwith-' . $osTag) !== '') {
                if ($element->getAttribute($osTag) === 'true') {
                    $definedForOS[] = $osName;
                } else {
                    $undefinedForOS[] = $osName;
                }
            }
        }
        if (count($undefinedForOS) === 0) {
            $result = '';
        } elseif (count($definedForOS) === 0) {
            $result = 'WARNING: this may not be available on ' . implode('/', $undefinedForOS);
        } else {
            $result = 'WARNING: this may be available on ' . implode('/', $definedForOS) . ' but not on ' . implode('/', $undefinedForOS);
        }
        return $result;
    }

    /**
     * Output a global constant.
     *
     * @param DOMElement $extensionElement
     *            The extension XML element
     * @param DOMElement $constantElement
     */
    private function writeGlobalConstant(DOMElement $extensionElement, DOMElement $constantElement)
    {
        $name = $constantElement->getAttribute('name');
        $value = new ValueData($constantElement->getAttribute('value'));
        $info = $this->phpManual->getItem($name, PHPManualItem::TYPE_GLOBALCONSTANT);
        $this->currentWriter->writeln();
        $this->currentWriter->writePHPDocParts(array(
            $info !== null ? $info->description : '',
            $this->getOSTagWarning($extensionElement, $constantElement),
            $info !== null && $info->url !== '' ? '@link ' . $info->url : '',
            '@var ' . $value->phpDocType
        ));
        if (version_compare($this->inputPhpVersion, '5.3') >= 0 && ! in_array($name, array(
            '__CLASS__',
            '__DIR__',
            '__FILE__',
            '__FUNCTION__',
            '__LINE__',
            '__METHOD__',
            '__NAMESPACE__',
            '__TRAIT__'
        ), true)) {
            $this->currentWriter->writeln("const {$name} = {$value->phpValue};");
        } else {
            $this->currentWriter->writeln("define('{$name}', {$value->phpValue});");
        }
    }

    /**
     * Output a trait.
     *
     * @param DOMElement $extensionElement
     *            The extension XML element
     * @param DOMElement $traitElement
     */
    private function writeTrait(DOMElement $extensionElement, DOMElement $traitElement)
    {
        $this->currentWriter->writeln();
        $name = $traitElement->getAttribute('name');
        $namespace = $traitElement->getAttribute('namespace');
        $fqName = ($namespace === '' ? '' : "{$namespace}\\") . $name;
        $info = $this->phpManual->getItem($fqName, PHPManualItem::TYPE_TRAIT);
        $this->currentWriter->writePHPDocParts(array(
            $info !== null ? $info->description : '',
            $this->getOSTagWarning($extensionElement, $traitElement),
            $info !== null ? $info->getVersionPHPDoc() : '',
            $info !== null && $info->url !== '' ? '@link ' . $info->url : ''
        ));
        $this->currentWriter->writeln("trait {$name}\n{");
        $this->currentWriter->increaseIndentation();
        $firstChildren = true;
        $this->writeClassProperties($extensionElement, $traitElement, $firstChildren);
        $this->writeClassMethods($extensionElement, $traitElement, $firstChildren);
        $this->currentWriter->decreaseIndentation();
        $this->currentWriter->writeln('}');
    }

    /**
     * Output an interface.
     *
     * @param DOMElement $extensionElement
     *            The extension XML element
     * @param DOMElement $interfaceElement
     */
    private function writeInterface(DOMElement $extensionElement, DOMElement $interfaceElement)
    {
        $this->currentWriter->writeln();
        $name = $interfaceElement->getAttribute('name');
        $namespace = $interfaceElement->getAttribute('namespace');
        $fqName = ($namespace === '' ? '' : "{$namespace}\\") . $name;
        $info = $this->phpManual->getItem($fqName, PHPManualItem::TYPE_INTERFACE);
        $this->currentWriter->writePHPDocParts(array(
            $info !== null ? $info->description : '',
            $this->getOSTagWarning($extensionElement, $interfaceElement),
            $info !== null ? $info->getVersionPHPDoc() : '',
            $info !== null && $info->url !== '' ? '@link ' . $info->url : ''
        ));
        $header = 'interface ' . $name;
        $extends = $interfaceElement->getAttribute('extends');
        if ($extends !== '') {
            $header .= ' extends ' . $extends;
        }
        $this->currentWriter->writeln($header . "\n{");
        $this->currentWriter->increaseIndentation();
        $firstChildren = true;
        $this->writeClassConstants($extensionElement, $interfaceElement, $firstChildren);
        $this->writeClassProperties($extensionElement, $interfaceElement, $firstChildren);
        $this->writeClassMethods($extensionElement, $interfaceElement, $firstChildren);
        $this->currentWriter->decreaseIndentation();
        $this->currentWriter->writeln('}');
    }

    /**
     * Output an class.
     *
     * @param DOMElement $extensionElement
     *            The extension XML element
     * @param DOMElement $classElement
     */
    private function writeClass(DOMElement $extensionElement, DOMElement $classElement)
    {
        $this->currentWriter->writeln();
        $name = $classElement->getAttribute('name');
        $namespace = $classElement->getAttribute('namespace');
        $fqName = ($namespace === '' ? '' : "{$namespace}\\") . $name;
        $info = $this->phpManual->getItem($fqName, PHPManualItem::TYPE_CLASS);
        $this->currentWriter->writePHPDocParts(array(
            $info !== null ? $info->description : '',
            $this->getOSTagWarning($extensionElement, $classElement),
            $info !== null ? $info->getVersionPHPDoc() : '',
            $info !== null && $info->url !== '' ? '@link ' . $info->url : ''
        ));
        $header = '';
        if ($classElement->getAttribute('abstract') === 'true') {
            $header .= 'abstract ';
            if ($classElement->getAttribute('final') === 'true') {
                $header .= '/*final*/ ';
            }
        } elseif ($classElement->getAttribute('final') === 'true') {
            if ($this->inputXPath->query('//ns:class[@extends="' . $this->escapeXML($fqName) . '"]')->length > 0 || $this->inputXPath->query('//ns:class[@extends="' . $this->escapeXML('\\' . $fqName) . '"]')->length > 0) {
                $header .= '/*final*/ ';
            } else {
                $header .= 'final ';
            }
        }
        $namePrefix = $namespace === '' ? '' : '\\';
        $header .= 'class ' . $name;
        if ($classElement->getAttribute('extends') !== '') {
            $header .= ' extends ' . $namePrefix . ltrim($classElement->getAttribute('extends'), '\\');
        }
        $implements = array();
        foreach ($this->inputXPath->query('./ns:implements', $classElement) as $implementsElement) {
            $implements[] = ltrim($implementsElement->getAttribute('name'), '\\');
        }
        if (count($implements) > 0) {
            $header .= ' implements ' . $namePrefix . implode(', ' . $namePrefix, $implements);
        }
        $this->currentWriter->writeln($header . "\n{");
        $this->currentWriter->increaseIndentation();
        $firstChildren = true;
        $this->writeClassConstants($extensionElement, $classElement, $firstChildren);
        $this->writeClassProperties($extensionElement, $classElement, $firstChildren);
        $this->writeClassMethods($extensionElement, $classElement, $firstChildren);
        $this->currentWriter->decreaseIndentation();
        $this->currentWriter->writeln('}');
    }

    /**
     * Output the interface/class constants.
     *
     * @param DOMElement $extensionElement
     *            The extension XML element
     * @param DOMElement $classElement
     *            The interface/class XML element
     * @param bool $firstChildren
     *            Is this the first child of the class?
     */
    private function writeClassConstants(DOMElement $extensionElement, DOMElement $classElement, &$firstChildren)
    {
        $prefix = null;
        foreach ($this->inputXPath->query('./ns:constant', $classElement) as $constantElement) {
            if ($firstChildren) {
                $firstChildren = false;
            } else {
                $this->currentWriter->writeln();
            }
            if ($prefix === null) {
                $namespace = $classElement->getAttribute('namespace');
                $className = $classElement->getAttribute('name');
                $prefix = $namespace === '' ? "{$className}::" : "{$namespace}\\{$className}::";
            }
            $name = $constantElement->getAttribute('name');
            $info = $this->phpManual->getItem($prefix . $name, PHPManualItem::TYPE_CLASSCONSTANT);
            $value = new ValueData($constantElement->getAttribute('value'));
            $this->currentWriter->writePHPDocParts(array(
                $info !== null ? $info->description : '',
                $this->getOSTagWarning($extensionElement, $constantElement),
                $info !== null ? $info->getVersionPHPDoc() : '',
                '@var ' . $value->phpDocType,
                $info !== null && $info->url !== '' ? '@link ' . $info->url : ''
            ));
            $this->currentWriter->writeln('const ' . $name . ' = ' . $value->phpValue . ';');
        }
    }

    /**
     * Output the trait/interface/class properties.
     *
     * @param DOMElement $extensionElement
     *            The extension XML element
     * @param DOMElement $classElement
     *            The trait/interface/class XML element
     * @param bool $firstChildren
     *            Is this the first child of the class?
     */
    private function writeClassProperties(DOMElement $extensionElement, DOMElement $classElement, &$firstChildren)
    {
        $prefix = null;
        foreach ($this->inputXPath->query('./ns:property', $classElement) as $propertyElement) {
            if ($firstChildren) {
                $firstChildren = false;
            } else {
                $this->currentWriter->writeln();
            }
            if ($prefix === null) {
                $namespace = $classElement->getAttribute('namespace');
                $className = $classElement->getAttribute('name');
                $prefix = $namespace === '' ? "{$className}::$" : "{$namespace}\\{$className}::$";
            }
            $name = $propertyElement->getAttribute('name');
            $info = $this->phpManual->getItem($prefix . $name, PHPManualItem::TYPE_CLASSPROPERTY);
            $value = new ValueData($propertyElement->getAttribute('defaultValue'));
            $this->currentWriter->writePHPDocParts(array(
                $info !== null ? $info->description : '',
                $this->getOSTagWarning($extensionElement, $propertyElement),
                $info !== null ? $info->getVersionPHPDoc() : '',
                '@var ' . ($value->phpDocType === 'null' ? 'mixed' : $value->phpDocType),
                $info !== null && $info->url !== '' ? '@link ' . $info->url : ''
            ));
            $line = $propertyElement->getAttribute('visibility') . ' $' . $propertyElement->getAttribute('name');
            if ($value->phpValue !== 'null') {
                $line .= ' = ' . $value->phpValue;
            }
            $line .= ';';
            $this->currentWriter->writeln($line);
        }
    }

    /**
     * Output the trait/interface/class methods.
     *
     * @param DOMElement $extensionElement
     *            The extension XML element
     * @param DOMElement $classElement
     *            The trait/interface/class XML element
     * @param bool $firstChildren
     *            Is this the first child of the class?
     */
    private function writeClassMethods(DOMElement $extensionElement, DOMElement $classElement, &$firstChildren)
    {
        foreach ($this->inputXPath->query('./ns:method', $classElement) as $methodElement) {
            if ($firstChildren) {
                $firstChildren = false;
            } else {
                $this->currentWriter->writeln();
            }
            $this->writeFunctionOrMethod($extensionElement, $methodElement, $classElement);
        }
    }

    /**
     * Output a global function.
     *
     * @param DOMElement $extensionElement
     *            The extension XML element
     * @param DOMElement $functionElement
     */
    private function writeGlobalFunction(DOMElement $extensionElement, DOMElement $functionElement)
    {
        $this->currentWriter->writeln();
        $this->writeFunctionOrMethod($extensionElement, $functionElement);
    }

    /**
     * Output a global function or a trait/interface/class method
     *
     * @param DOMElement $extensionElement
     *            The extension XML element
     * @param DOMElement $element
     *            The function/method XML node
     * @param DOMElement $parentElement
     *            The parent trait/interface/class XML node (if it's not a global function)
     */
    private function writeFunctionOrMethod(DOMElement $extensionElement, DOMElement $functionElement, DOMElement $parentElement = null)
    {
        $name = $functionElement->getAttribute('name');
        $namespace = $parentElement === null ? $functionElement->getAttribute('namespace') : $parentElement->getAttribute('namespace');
        $fqName = ($namespace === '' ? '' : "{$namespace}\\");
        if ($parentElement !== null) {
            $fqName .= $parentElement->getAttribute('name') . '::';
        }
        $fqName .= $name;
        $info = $this->phpManual->getItem($fqName, $parentElement === null ? PHPManualItem::TYPE_GLOBALFUNCTION : PHPManualItem::TYPE_CLASSMETHOD);

        $fullInfo = new PHPManualMergedFunction($extensionElement, $functionElement, $parentElement, $info);

        $returnPHPDoc = '';
        $returnType = $this->typeFormatter->format($fullInfo->rawReturnType, $fullInfo->returnTypeAllowsNull, $namespace, TypeFormatter::PLACE_DOC_RETURNTYPE);
        if ($returnType !== '') {
            $returnPHPDoc = "@return $returnType";
            if ($info !== null && $info->functionReturnDescription !== '') {
                $returnPHPDoc .= ' ' . $info->functionReturnDescription;
            }
        }

        $this->currentWriter->writePHPDocParts(array(
            $info !== null ? $info->description : '',
            $this->getOSTagWarning($extensionElement, $functionElement),
            $fullInfo->getParametersPHPDoc($namespace, $this->typeFormatter),
            $returnPHPDoc,
            $fullInfo->getVersionPHPDoc(),
            $info !== null && $info->url !== '' ? '@link ' . $info->url : ''
        ));
        $header = '';
        $withoutBody = $parentElement !== null && ($parentElement->nodeName === 'interface' || $functionElement->getAttribute('abstract') === 'true');
        if ($parentElement !== null) {
            if ($parentElement->nodeName !== 'interface') {
                if ($functionElement->getAttribute('abstract') === 'true') {
                    $header .= 'abstract ';
                } elseif ($functionElement->getAttribute('final') === 'true') {
                    $header .= 'final ';
                }
            }
            $header .= $functionElement->getAttribute('visibility') . ' ';
            if ($functionElement->getAttribute('static') === 'true') {
                $header .= 'static ';
            }
        }
        $header .= 'function ';
        if ($functionElement->getAttribute('returnsReference') === 'true') {
            $header .= '&';
        }
        $header .= $name . '(';
        $firstParameter = true;
        foreach ($fullInfo->parameters as $parameter) {
            if ($firstParameter === true) {
                $firstParameter = false;
            } else {
                $header .= ', ';
            }
            $header .= $parameter->renderAsPHPCode($namespace, $this->typeFormatter);
        }
        $header .= ')';
        $returnType = $this->typeFormatter->format($fullInfo->rawReturnType, $fullInfo->returnTypeAllowsNull, $namespace, TypeFormatter::PLACE_CODE_RETURNTYPE);
        if ($returnType !== '') {
            $header .= ': ' . $returnType;
        }
        if ($withoutBody) {
            $header .= ';';
            $this->currentWriter->writeln($header);
        } else {
            $this->currentWriter->writeln($header);
            $this->currentWriter->writeln('{');
            $this->currentWriter->writeln('}');
        }
    }

    /**
     * Escape a string so that in can be safely represented in the XML file.
     *
     * @param string $s
     *            The string to be escaped.
     *            
     * @return string
     */
    private function escapeXML($s)
    {
        return defined('ENT_XML1') ? htmlspecialchars($s, ENT_XML1, 'UTF-8') : strtr($s, array(
            "&" => "&amp;",
            '"' => '&quot;',
            "'" => '&apos;',
            "<" => "&lt;",
            ">" => "&gt;"
        ));
    }
}

/**
 * Helper class to be used when writing a serialized value to a PHP stub file.
 */
class ValueData
{

    /**
     * The type to be used in PHPDocs.
     *
     * @property-read
     *
     * @var string
     */
    public $phpDocType;

    /**
     * The value to be written as PHP code.
     *
     * @property-read
     *
     * @var string
     */
    public $phpValue;

    /**
     * Initialize the instance.
     *
     * @param string $serializedValue
     *            The value as saved in the XML file.
     */
    public function __construct($serializedValue)
    {
        $this->phpValue = $serializedValue;
        $value = null;
        eval("\$value = {$serializedValue};");
        $this->phpDocType = gettype($value);
        if ($this->phpDocType === 'string' && strpos($value, '[resource]') === 0) {
            $this->phpDocType = 'resource';
            $this->phpValue = str_replace('[resource]', '', $this->phpValue);
        } else {
            switch ($this->phpDocType) {
                case 'boolean':
                    $this->phpDocType = 'bool';
                    break;
                case 'integer':
                    $this->phpDocType = 'int';
                    break;
                case 'double':
                    $this->phpDocType = 'float';
                    break;
                case 'NULL':
                    $this->phpDocType = 'null';
                    break;
            }
        }
    }
}

/**
 * Helper class to be used to get info from the PHP manual.
 */
class PHPManual
{

    /**
     * The regular expression that describes valid XML entity names.
     *
     * @var string
     *
     * @see https://www.w3.org/TR/xml/#NT-Name
     */
    const RX_ENTITYNAME = '[A-Z_a-z\xc0-\xd6\xd8-\xf6][A-Z_a-z\xc0-\xd6\xd8-\xf6\-.0-9\xb7]*';

    use VerboseTrait;

    /**
     * The directory that contains a clone of https://svn.php.net/repository/phpdoc/doc-base/trunk (or the trunk directory of https://github.com/svn2github/phpdoc_doc-base )
     *
     * @var string
     */
    private $docBaseDirectory;

    /**
     * The directory that contains a clone of https://svn.php.net/repository/phpdoc/en/trunk (or the trunk directory of https://github.com/svn2github/phpdoc_en )
     *
     * @var string
     */
    private $docDirectory;

    /**
     * The PHPManualCache instance to be used.
     *
     * @var PHPManualCache
     */
    private $cache;

    /**
     * A temporar array used to build the XML entities.
     *
     * @var array|null
     */
    private $temporaryEntities;

    /**
     * A prepared version of entities to be used to replace values in XML files.
     *
     * @var array|null
     */
    private $entityMap;

    /**
     * The XSLTProcessor instance to be used to convert XML to PHPDoc.
     *
     * @var XSLTProcessor|null
     */
    private $xsltProcessor;

    /**
     * Initialize the instance.
     *
     * @param string $docBaseDirectory
     *            The directory that contains a clone of https://svn.php.net/repository/phpdoc/doc-base/trunk (or the trunk directory of https://github.com/svn2github/phpdoc_doc-base )
     * @param string $docDirectory
     *            The directory that contains a clone of https://svn.php.net/repository/phpdoc/en/trunk (or the trunk directory of https://github.com/svn2github/phpdoc_en )
     * @param PHPManualCache $cache
     * @param bool $verbose
     */
    public function __construct($docBaseDirectory, $docDirectory, PHPManualCache $cache, $verbose)
    {
        $this->verbose = (bool) $verbose;
        $this->cache = $cache;
        $f = realpath($docBaseDirectory);
        if (! is_dir($f)) {
            throw new UserMessageException("Unable to find the doc-base directory {$docBaseDirectory}");
        }
        $this->docBaseDirectory = str_replace(DIRECTORY_SEPARATOR, '/', $f);
        if (! is_file($this->docBaseDirectory . '/configure.php')) {
            if (is_dir($this->docBaseDirectory . '/branches') && is_dir($this->docBaseDirectory . '/tags') && is_dir($this->docBaseDirectory . '/trunk') && is_file($this->docBaseDirectory . '/trunk/configure.php')) {
                $this->docBaseDirectory .= '/trunk';
            } else {
                throw new UserMessageException("The doc-base directory {$this->docBaseDirectory} is wrong");
            }
        }
        $f = realpath($docDirectory);
        if (! is_dir($f)) {
            throw new UserMessageException("Unable to find the doc directory {$docDirectory}");
        }
        $this->docDirectory = str_replace(DIRECTORY_SEPARATOR, '/', $f);
        if (! is_file($this->docDirectory . '/bookinfo.xml')) {
            if (is_dir($this->docDirectory . '/branches') && is_dir($this->docDirectory . '/tags') && is_dir($this->docDirectory . '/trunk') && is_file($this->docDirectory . '/trunk/bookinfo.xml')) {
                $this->docDirectory .= '/trunk';
            } else {
                throw new UserMessageException("The doc directory {$this->docDirectory} is wrong");
            }
        }
    }

    /**
     * Prefetch reference data.
     * This is not mandatory, it's here just for display purposes.
     */
    public function prefetch()
    {
        if (! $this->cache->has(PHPManualCache::KEY_DOCUMENTIDMAP)) {
            echo "Prefetching document IDs\n";
            $this->getDocumentIDMap();
        }
        if (! $this->cache->has(PHPManualCache::KEY_XMLENTITIES)) {
            echo "Prefetching manual entities\n";
            $this->getEntityMap();
        }
        if (! $this->cache->has(PHPManualCache::KEY_ITEMS)) {
            echo "Prefetching manual items\n";
            $this->getPHPManualItems();
        }
    }

    /**
     * Get the PHP Manual info about an item.
     *
     * @param string $name
     *            The item name.
     * @param int $type
     *            The item type.
     *            
     * @return PHPManualItem|null
     */
    public function getItem($name, $type)
    {
        $items = $this->getPHPManualItems();
        return $items->get($name, $type);
    }

    private function getDocumentIDMap()
    {
        $result = $this->cache->get(PHPManualCache::KEY_DOCUMENTIDMAP);
        if ($result === null) {
            $m = null;
            $result = array();
            $prefixLength = strlen($this->docDirectory) + 1;
            $xmlFiles = new RegexIterator(new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this->docDirectory, FilesystemIterator::SKIP_DOTS | FilesystemIterator::UNIX_PATHS), RecursiveIteratorIterator::LEAVES_ONLY), '/\.(xml)$/i', RegexIterator::MATCH);
            foreach ($xmlFiles as $xmlFile) {
                $xmlFileObject = $xmlFile->openFile('r');
                $inComment = false;
                $firstElement = '';
                while (! $xmlFileObject->eof() && strpos($firstElement, '>') === false) {
                    $line = $xmlFileObject->fgets();
                    for (;;) {
                        $line = preg_replace('/<!--.*?-->/', '', $line);
                        if ($inComment) {
                            if (preg_match('/^.*?-->(.*)$/', $line, $m)) {
                                $line = $m[1];
                                $inComment = false;
                            } else {
                                $line = '';
                                break;
                            }
                        } else {
                            if (preg_match('/^(.*?)<!--/', $line, $m)) {
                                $line = $m[1];
                                $inComment = true;
                            }
                            break;
                        }
                    }
                    if ($firstElement === '') {
                        if (preg_match('/^.*?(<\w.*)$/', $line, $m)) {
                            $firstElement = $line;
                        }
                    } else {
                        $firstElement .= ' ' . $line;
                    }
                }
                $xmlFileObject = null;
                $p = strpos($firstElement, '>');
                if ($p !== false) {
                    $firstElement = substr($firstElement, 0, $p + 1);
                    if (preg_match('/<([^\s]+)\s(?:.*\s)?xml:id\s*=\s*([\'"])(.*?)\2/', $firstElement, $m)) {
                        switch ($m[1]) {
                            case 'book':
                                break;
                            default:
                                if (isset($result[$m[3]])) {
                                    throw new Exception("Duplicated document ID: {$m[3]}");
                                }
                                $section = explode('/', substr($xmlFile->getPathname(), strlen($this->docDirectory) + 1), 2);
                                $section = isset($section[1]) ? array_shift($section) : '';
                                $result[$m[3]] = array(
                                    'section' => $section,
                                    'file' => substr($xmlFile->getPathname(), $prefixLength),
                                    'includedIn' => array(),
                                    'includedWithSectionIn' => array()
                                );
                                break;
                        }
                    }
                }
            }
            foreach ($xmlFiles as $xmlFile) {
                if (preg_match_all('/&(' . self::RX_ENTITYNAME . ');/', file_get_contents($xmlFile->getPathname()), $m) > 0) {
                    foreach ($m[1] as $entityId) {
                        if (isset($result[$entityId])) {
                            $result[$entityId]['includedIn'][] = substr($xmlFile->getPathname(), $prefixLength);
                        } elseif (strpos($entityId, '.') !== false) {
                            list ($section, $id) = explode('.', $entityId, 2);
                            if (isset($result[$id]) && $result[$id]['section'] === $section) {
                                $result[$id]['includedWithSectionIn'][] = substr($xmlFile->getPathname(), $prefixLength);
                            }
                        }
                    }
                }
            }
            $result = array_filter($result, function (array $entity) {
                return count($entity['includedIn']) > 0 || count($entity['includedWithSectionIn']) > 0;
            });
            ksort($result);
            $this->cache->set(PHPManualCache::KEY_DOCUMENTIDMAP, $result);
        }
        return $result;
    }

    /**
     * Get all the defined XML entities (array keys are the entity names, array values are the entity values).
     *
     * @return array
     */
    private function getEntities()
    {
        $result = $this->cache->get(PHPManualCache::KEY_XMLENTITIES);
        if ($result === null) {
            $result = array();
            foreach (array(
                $this->docBaseDirectory,
                $this->docDirectory
            ) as $dir) {
                $files = new RegexIterator(new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir, FilesystemIterator::SKIP_DOTS | FilesystemIterator::UNIX_PATHS), RecursiveIteratorIterator::LEAVES_ONLY), '/\.(ent)$/i', RegexIterator::MATCH);
                foreach ($files as $file) {
                    $matches = null;
                    if (preg_match_all('/<!ENTITY\s+(' . self::RX_ENTITYNAME . ')\s+(["\'])(.*?)\2>/s', file_get_contents($file->getPathname()), $matches) > 0) {
                        foreach ($matches[1] as $k => $v) {
                            $result[$v] = $matches[3][$k];
                        }
                    }
                }
            }
            $this->temporaryEntities = $result;
            $result = array_map(array(
                $this,
                'resolveEntity'
            ), $result);
            $this->temporaryEntities = null;
            $this->cache->set(PHPManualCache::KEY_XMLENTITIES, $result);
        }

        return $result;
    }

    /**
     * Replace all the XML entities defined in a XML chunk.
     *
     * @param string $text
     *
     * @throws Exception
     *
     * @return string
     */
    private function resolveEntity($text)
    {
        $result = $text;
        $matches = null;
        $count = preg_match_all('/(&(' . self::RX_ENTITYNAME . ');)/', $result, $matches);
        for ($i = 0; $i < $count; $i ++) {
            switch ($matches[2][$i]) {
                case 'quot':
                case 'amp':
                case 'apos':
                case 'lt':
                case 'gt':
                    break;
                default:
                    if (! isset($this->temporaryEntities[$matches[2][$i]])) {
                        throw new Exception('Unrecognized entity: ' . $matches[2][$i]);
                    }
                    $resolved = $this->resolveEntity($this->temporaryEntities[$matches[2][$i]]);
                    $result = str_replace($matches[1][$i], $resolved, $result);
                    break;
            }
        }
        return $result;
    }

    /**
     * Load an XML file, replacing all the XML entities.
     *
     * @param SplFileInfo|string $file
     *
     * @return DOMDocument
     */
    private function loadXmlFile($file)
    {
        $path = $file instanceof SplFileInfo ? $file->getPathname() : (string) $file;
        $xml = file_get_contents($path);
        $map = $this->getEntityMap();
        $xml = str_replace(array_keys($map), array_values($map), $xml);
        $xml = str_replace('{PATH_TO_DOCBASE}', 'file:///' . $this->docBaseDirectory, $xml);
        $xml = str_replace('{PATH_TO_DOC}', 'file:///' . $this->docDirectory, $xml);
        $matches = null;
        $numMatches = preg_match_all('/(&(' . self::RX_ENTITYNAME . ');)/', $xml, $matches);
        for ($i = 0; $i < $numMatches; $i ++) {
            $entityName = $matches[2][$i];
            switch ($entityName) {
                case 'quot':
                case 'amp':
                case 'apos':
                case 'lt':
                case 'gt':
                    break;
                default:
                    $map = $this->getDocumentIDMap();
                    if (isset($map[$entityName])) {
                        $text = "[[ENTITY:{$entityName}]]";
                    } else {
                        $text = null;
                        if (strpos($entityName, '.') !== false) {
                            list ($section, $actualEntityName) = explode('.', $entityName, 2);
                            if (isset($map[$actualEntityName]) && $map[$actualEntityName]['section'] === $section) {
                                $text = "[[ENTITY:{$actualEntityName}]]";
                            } elseif (preg_match('/^.+\.entities\..+$/', $entityName)) {
                                $d = str_replace('.', '/', str_replace('.entities.', '.', $entityName));
                                if (is_dir($this->docDirectory . '/' . $d)) {
                                    $text = "[[DIRECTORY:{$d}]]";
                                }
                            }
                            if ($text === null) {
                                $f = str_replace('.', '/', $entityName) . '.xml';
                                if (is_file($this->docDirectory . '/' . $f)) {
                                    $text = "[[FILE:{$f}]]";
                                } else {
                                    $f = str_replace('.', '/', str_replace('-', '_', $entityName)) . '.xml';
                                    if (is_file($this->docDirectory . '/' . $f)) {
                                        $text = "[[FILE:{$f}]]";
                                    }
                                }
                            }
                        }
                    }
                    if ($text === null) {
                        $xml = str_replace($matches[1][$i], "[[ENTITY-UNKNOWN:{$entityName}]]", $xml);
                    } else {
                        $xml = str_replace($matches[1][$i], $text, $xml);
                    }
                    break;
            }
        }
        $xmlDocument = new DOMDocument('1.0', 'UTF-8');
        $loadOptions = LIBXML_NOCDATA;
        if (defined('LIBXML_BIGLINES')) {
            $loadOptions |= LIBXML_BIGLINES;
        }
        try {
            $xmlDocument->loadXML($xml, $loadOptions);
        } catch (ErrorException $x) {
            throw new UserMessageException('Failed to load XML file ' . str_replace('/', DIRECTORY_SEPARATOR, $path) . ': ' . $x->getMessage());
        }
        return $xmlDocument;
    }

    /**
     * Get a prepared version of entities to be used to replace values in XML files.
     *
     * @return array
     */
    private function getEntityMap()
    {
        if ($this->entityMap === null) {
            $entityMap = array();
            foreach ($this->getEntities() as $entity => $value) {
                $entityMap['&' . $entity . ';'] = $value;
            }
            $this->entityMap = $entityMap;
        }

        return $this->entityMap;
    }

    /**
     * Get the XSLTProcessor instance to be used to convert XML to PHPDoc.
     *
     * @return XSLTProcessor
     */
    private function getXSLTProcessor()
    {
        if ($this->xsltProcessor === null) {
            $xsltDocument = new DOMDocument('1.0', 'UTF-8');
            $xsltDocument->loadXML(<<<'EOT'
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output
        method="xml"
        encoding="UTF-8"
        omit-xml-declaration="yes"
        standalone="no"
        indent="no"
    />
    <xsl:template match="@*|node()"><xsl:copy><xsl:apply-templates select="@*|node()" /></xsl:copy></xsl:template>
    <xsl:template match="informaltable"><table><xsl:apply-templates select="@*|node()" /></table></xsl:template>
    <xsl:template match="row"><tr><xsl:apply-templates select="@*|node()" /></tr></xsl:template>
    <xsl:template match="entry"><td><xsl:apply-templates select="@*|node()" /></td></xsl:template>
    <xsl:template match="variablelist|simplelist|itemizedlist"><ul><xsl:apply-templates select="@*|node()" /></ul></xsl:template>
    <xsl:template match="varlistentry|member"><li><xsl:apply-templates select="@*|node()" /></li></xsl:template>
    <xsl:template match="refpurpose|para|simpara|listitem"><xsl:apply-templates select="node()" />
</xsl:template>
    <xsl:template match="property|interfacename|filename|emphasis|varname|modifier|classname|literal|constant|option|acronym|function|methodname|type|parameter|term"><code><xsl:apply-templates select="@*|node()" /></code></xsl:template>
    <xsl:template match="ooclass"><xsl:apply-templates select="node()" /></xsl:template>
    <xsl:template match="xref"><xsl:value-of select="@linked" /></xsl:template>
    <xsl:template match="link"><xsl:apply-templates select="node()" /></xsl:template>
    <xsl:template match="tgroup"><xsl:apply-templates select="node()" /></xsl:template>
    <xsl:template match="note|example"><blockquote><xsl:apply-templates select="node()" /></blockquote></xsl:template>
    <xsl:template match="programlisting|screen"><blockquote><pre><xsl:apply-templates select="node()" /></pre></blockquote></xsl:template>
    <xsl:template match="quote"><q><xsl:apply-templates select="node()" /></q></xsl:template>
    <xsl:template match="warning">WARNING: <xsl:apply-templates select="node()" /></xsl:template>
</xsl:stylesheet>
EOT
);
            $xsltProcessor = new XSLTProcessor();
            $xsltProcessor->importStylesheet($xsltDocument);
            $this->xsltProcessor = $xsltProcessor;
        }
        return $this->xsltProcessor;
    }

    /**
     * Simplify the text extracted from XML.
     *
     * @param $str string
     *
     * @return string
     */
    private function simplifyPHPDoc($str)
    {
        // Replace TABs with spaces
        $str = str_replace("\t", ' ', $str);
        // Normalize newlines
        $str = str_replace("\r", "\n", str_replace("\r\n", "\n", $str));
        // Reduce multiple spaces to 1
        $str = preg_replace('/  +/', ' ', $str);
        // Remove spaces at beginning/end of lines
        $str = preg_replace('/ ?\n ?/s', "\n", $str);
        // Reduce multiple new-lines to 1
        $str = preg_replace('/\n\n+/s', "\n", $str);
        // Table cells on same line
        $str = preg_replace('%</td>\n<td%s', '</td><td', $str);
        // Escape comments
        $str = str_replace('/*', '&#47;&#42;', $str);
        $str = str_replace('*/', '&#42;&#47;', $str);

        return trim($str);
    }

    /**
     * Convert the content of an XML element to a PHPDoc text string.
     *
     * @param DOMElement $element
     *
     * @return string
     */
    private function innerXmlToPHPDoc(DOMElement $element)
    {
        $chunks = array();
        foreach ($element->childNodes as $childNode) {
            switch ($childNode->nodeType) {
                case XML_ELEMENT_NODE:
                    $chunks[] = $this->outerXmlToPHPDoc($childNode);
                    break;
                case XML_TEXT_NODE:
                    $chunks[] = $childNode->wholeText;
                    break;
                case XML_CDATA_SECTION_NODE:
                    $chunks[] = $childNode->data;
                    break;
            }
        }
        $result = implode('', $chunks);

        return $result;
    }

    /**
     * Convert an XML element to a PHPDoc text string.
     *
     * @param DOMElement $element
     *
     * @return string
     */
    private function outerXmlToPHPDoc(DOMElement $element)
    {
        $sourceXML = $element->ownerDocument->saveXML($element);
        // Remove 'xmlns="..."' attributes
        $sourceXML = preg_replace('/(<\w[^>]*)\sxmlns\s*=\s*(["\']).*?\2/s', '\1', $sourceXML);
        // Remove attribute namespaces
        $sourceXML = preg_replace('/(<\w[^>]*\s)(?:\w+:)(\w)/s', '\1\2', $sourceXML);
        $processor = $this->getXSLTProcessor();
        $sourceDocument = new DOMDocument('1.0', 'UTF-8');
        try {
            $sourceDocument->loadXML(<<<EOT
<?xml version="1.0" encoding="UTF-8"?>
{$sourceXML}
EOT
);
            $outputDocument = $processor->transformToXML($sourceDocument);
        } catch (ErrorException $x) {
            throw new Exception('Failed to convert XML to PHPDoc: ' . $x->getMessage());
        }

        return $outputDocument;
    }

    /**
     * Get the list of items read from the PHP Manual
     *
     * @return PHPManualItems
     */
    private function getPHPManualItems()
    {
        $result = $this->cache->get(PHPManualCache::KEY_ITEMS);
        if (! $result instanceof PHPManualItems) {
            $result = new PHPManualItems();
            $relativePrefixLength = strlen($this->docDirectory);
            foreach (array(
                $this->docDirectory . '/reference',
                $this->docDirectory . '/language'
            ) as $dir) {
                $xmlFiles = new RegexIterator(new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir, FilesystemIterator::SKIP_DOTS | FilesystemIterator::UNIX_PATHS), RecursiveIteratorIterator::LEAVES_ONLY), '/\.xml$/i', RegexIterator::MATCH);
                foreach ($xmlFiles as $xmlFile) {
                    $xmlFileRelativePath = substr($xmlFile->getPathname(), $relativePrefixLength);
                    switch ($xmlFileRelativePath) {
                        // Skip broken XML files
                        case '/reference/wkhtmltox/wkhtmltox/bits/load.xml':
                        case '/reference/wkhtmltox/wkhtmltox/bits/web.xml':
                            continue 2;
                    }
                    $xmlDocument = $this->loadXmlFile($xmlFile);
                    $xPath = new MyDOMXPath($xmlDocument, 'http://docbook.org/ns/docbook');
                    $this->parseVersions($xmlFileRelativePath, $xmlDocument, $xPath, $result);
                    $this->parseConstants($xmlFileRelativePath, $xmlDocument, $xPath, $result);
                    $this->parseClasses($xmlFileRelativePath, $xmlDocument, $xPath, $result);
                    $this->parseFunctions($xmlFileRelativePath, $xmlDocument, $xPath, $result);
                }
            }
            $this->cache->set(PHPManualCache::KEY_ITEMS, $result);
        }
        return $result;
    }

    /**
     * Parse all the version-related data defined in the PHP manual.
     *
     * @param string $xmlFileRelativePath
     * @param DOMDocument $xmlDocument
     * @param $xmlDocument $xPath
     * @param PHPManualItems $items
     */
    private function parseVersions($xmlFileRelativePath, DOMDocument $xmlDocument, MyDOMXPath $xPath, PHPManualItems $items)
    {
        if ($xmlDocument->documentElement->nodeName === 'versions') {
            foreach ($xmlDocument->documentElement->childNodes as $xmlVersion) {
                if ($xmlVersion instanceof DOMElement && $xmlVersion->tagName === 'function') {
                    $name = trim($xmlVersion->getAttribute('name'));
                    if ($name !== '') {
                        $item = $items->getOrCreate($name, PHPManualItem::TYPE_GLOBALVARIABLE | PHPManualItem::TYPE_GLOBALFUNCTION | PHPManualItem::TYPE_TRAIT | PHPManualItem::TYPE_INTERFACE | PHPManualItem::TYPE_CLASS | PHPManualItem::TYPE_CLASSMETHOD, true);
                        foreach ($xmlVersion->attributes as $attributeName => $domAttr) {
                            $value = trim($domAttr->value);
                            if ($value !== '') {
                                switch ($attributeName) {
                                    case 'from':
                                        $item->versionFrom = $value;
                                        break;
                                    case 'to':
                                        $item->versionTo = $value;
                                        break;
                                    case 'deprecated':
                                        $item->versionDeprecated = $value;
                                        break;
                                    case 'removed':
                                        $item->versionRemoved = $value;
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Parse all the constants defined in the PHP manual.
     *
     * @param string $xmlFileRelativePath
     * @param DOMDocument $xmlDocument
     * @param $xmlDocument $xPath
     * @param PHPManualItems $items
     */
    private function parseConstants($xmlFileRelativePath, DOMDocument $xmlDocument, MyDOMXPath $xPath, PHPManualItems $items)
    {
        if (preg_match('/[^a-zA-Z0-9]constants([-.]\w+)?\.xml$/', $xmlFileRelativePath) || substr($xmlFileRelativePath, - strlen('/file-upload.xml')) === '/file-upload.xml' || substr($xmlFileRelativePath, - strlen('/appendices/tokens.xml')) === '/appendices/tokens.xml') {
            foreach (array(
                array(
                    '//ns:term/ns:constant',
                    '../../ns:listitem'
                ),
                array(
                    '//ns:entry/ns:constant',
                    '../following-sibling::ns:entry'
                )
            ) as $searchPattern) {
                $xmlConstants = $xPath->query($searchPattern[0]);
                foreach ($xmlConstants as $xmlConstant) {
                    $name = $xmlConstant->nodeValue;
                    $item = $items->getOrCreate($name, PHPManualItem::TYPE_GLOBALCONSTANT, true);
                    if ($item->url === '') {
                        $item->url = $this->getManualURL($xmlConstant, $xPath);
                    }
                    if ($item->description === '') {
                        $listItem = $xPath->queryFirstElement($searchPattern[1], $xmlConstant);
                        if ($listItem !== null) {
                            $item->description = $this->simplifyPHPDoc($this->innerXmlToPHPDoc($listItem));
                        }
                    }
                }
            }
        }
    }

    /**
     * Parse all the classes defined in the PHP manual.
     *
     * @param string $xmlFileRelativePath
     * @param DOMDocument $xmlDocument
     * @param $xmlDocument $xPath
     * @param PHPManualItems $items
     */
    private function parseClasses($xmlFileRelativePath, DOMDocument $xmlDocument, MyDOMXPath $xPath, PHPManualItems $items)
    {
        if ((strpos($xmlFileRelativePath, '/language/') === 0 || strpos($xmlFileRelativePath, '/reference/') === 0) && $xmlDocument->documentElement->localName !== 'book') {
            foreach ($xPath->query('//ns:titleabbrev') as $titleAbbrevElement) {
                $className = trim($titleAbbrevElement->textContent);
                $item = $items->getOrCreate($className, PHPManualItem::TYPE_TRAIT | PHPManualItem::TYPE_INTERFACE | PHPManualItem::TYPE_CLASS, true);
                if ($item->url === '') {
                    $item->url = $this->getManualURL($titleAbbrevElement, $xPath);
                }
                if ($item->description === '') {
                    foreach ($xPath->query('//ns:section/ns:para') as $paraElement) {
                        $item->description = $this->simplifyPHPDoc($this->outerXmlToPHPDoc($paraElement));
                        if ($item->description !== '') {
                            break;
                        }
                    }
                }
            }
        }
    }

    /**
     * Parse all the functions defined in the PHP manual.
     *
     * @param string $xmlFileRelativePath
     * @param DOMDocument $xmlDocument
     * @param $xmlDocument $xPath
     * @param PHPManualItems $items
     */
    private function parseFunctions($xmlFileRelativePath, DOMDocument $xmlDocument, MyDOMXPath $xPath, PHPManualItems $items)
    {
        foreach ($xPath->query('//ns:refentry//ns:refname') as $refName) {
            $refPurpose = $xPath->queryFirstElement('../ns:refpurpose', $refName);
            if ($refPurpose !== null) {
                $refEntry = $xPath->queryFirstElement('./ancestor::ns:refentry', $refName);
                $name = $this->normalizeFunctionName($refName->nodeValue);
                $item = $items->getOrCreate($name, PHPManualItem::TYPE_CLASSMETHOD | PHPManualItem::TYPE_GLOBALFUNCTION, true);
                if ($item->url === '') {
                    $item->url = $this->getManualURL($refName, $xPath);
                }
                if ($item->description === '') {
                    $item->description = $this->simplifyPHPDoc($this->outerXmlToPHPDoc($refPurpose));
                }
                if (substr($name, - strlen('::__construct')) === '::__construct') {
                    $synopsisName = 'constructorsynopsis';
                } elseif (substr($name, - strlen('::__destruct')) === '::__destruct') {
                    $synopsisName = 'destructorsynopsis';
                } else {
                    $synopsisName = 'methodsynopsis';
                }
                $synopsis = $xPath->queryFirstElement('.//ns:refsect1[@role="description"]//ns:' . $synopsisName, $refEntry);
                if ($synopsis !== null && $item->functionParameters === []) {
                    foreach ($xPath->query('.//ns:methodparam', $synopsis) as $xmlParam) {
                        $parameterItem = new PHPManualFunctionParameter();
                        $xmlType = $xPath->queryFirstElement('.//ns:type', $xmlParam);
                        if ($xmlType !== null) {
                            $parameterItem->type = trim($xmlType->nodeValue);
                        }
                        $xmlName = $xPath->queryFirstElement('.//ns:parameter', $xmlParam);
                        if ($xmlName !== null) {
                            $parameterItem->name = str_replace('...', '', ltrim(trim($xmlName->nodeValue), '$'));
                        }
                        $xmlDefaultValue = $xPath->queryFirstElement('.//ns:initializer', $xmlParam);
                        if ($xmlDefaultValue !== null) {
                            $defaultValue = trim($xmlDefaultValue->nodeValue);
                            switch ($defaultValue) {
                                case 'FALSE':
                                    $parameterItem->defaultValue = 'false';
                                    break;
                                case 'TRUE':
                                    $parameterItem->defaultValue = 'true';
                                    break;
                                case 'NULL':
                                    $parameterItem->defaultValue = 'null';
                                    break;
                                default:
                                    $parameterItem->defaultValue = $defaultValue;
                                    break;
                            }
                        }
                        $item->functionParameters[] = $parameterItem;
                    }
                    $parametersSection = $xPath->queryFirstElement('.//ns:refsect1[@role="parameters"]', $refEntry);
                    if ($parametersSection !== null) {
                        $index = 0;
                        foreach ($xPath->query('.//ns:varlistentry', $parametersSection) as $varListEntry) {
                            $termParameter = $xPath->queryFirstElement('.//ns:term/ns:parameter', $varListEntry);
                            if ($termParameter !== null) {
                                $parameterName = str_replace('...', '', ltrim(trim($termParameter->nodeValue), '$'));
                                foreach ($item->functionParameters as $parameterItemIndex => $parameterItem) {
                                    if ($parameterItem->name === $parameterName && ($parameterName !== '' || $index === $parameterItemIndex)) {
                                        $para = $xPath->queryFirstElement('../../ns:listitem//ns:para', $termParameter);
                                        if ($para !== null) {
                                            $parameterItem->description = $this->simplifyPHPDoc($this->outerXmlToPHPDoc($para));
                                        }
                                        break;
                                    }
                                }
                            }
                            $index ++;
                        }
                    }
                }
                if ($synopsis !== null && $item->functionReturnType === '') {
                    $synopsisType = $xPath->queryFirstElement('./ns:type', $synopsis);
                    if ($synopsisType !== null) {
                        $methodNames = $xPath->query('../ns:methodname', $synopsisType);
                        if ($methodNames->length > 0) {
                            $item->functionReturnType = $synopsisType->nodeValue;
                        }
                    }
                }
                if ($item->functionReturnDescription === '') {
                    $parts = array();
                    foreach ($xPath->query('.//ns:refsect1[@role="returnvalues"]/ns:para', $refEntry) as $para) {
                        $parts[] = $this->simplifyPHPDoc($this->innerXmlToPHPDoc($para));
                    }
                    $item->functionReturnDescription = implode("\n", $parts);
                }
            }
        }
    }

    /**
     * Normalize a function/method name.
     *
     * @param string $name
     *
     * @return string
     */
    private function normalizeFunctionName($name)
    {
        return str_replace('()', '', str_replace('->', '::', $name));
    }

    /**
     * Get the URL of the PHP manual corresponding to an XML element.
     *
     * @param DOMElement $xmlElement
     * @param MyDOMXPath $xPath
     *
     * @return string
     */
    private function getManualURL(DOMElement $xmlElement, MyDOMXPath $xPath = null)
    {
        if ($xPath === null) {
            $xPath = new MyDOMXPath($xmlElement->ownerDocument, 'http://docbook.org/ns/docbook');
        }
        $result = '';
        $rootID = '';
        $hashID = '';
        $elementsWithID = $xPath->query('./ancestor-or-self::*[@xml:id]', $xmlElement);
        for ($i = $elementsWithID->length - 1; $i >= 0; $i --) {
            $id = $elementsWithID->item($i)->getAttribute('xml:id');
            switch ($elementsWithID->item($i)->localName) {
                case 'book':
                case 'chapter':
                case 'sect1':
                case 'appendix':
                case 'reference':
                case 'classref':
                    $rootID = $id;
                    break 2;
                case 'section':
                    $hashID = $id;
                    if ($xmlElement->ownerDocument->documentElement === $elementsWithID->item($i)) {
                        $map = $this->getDocumentIDMap();
                        if (isset($map[$id])) {
                            $result = $this->getManualURL($this->loadXmlFile($this->docDirectory . '/' . $map[$id]['includedWithSectionIn'][0])->documentElement);
                            break 2;
                        }
                    }
                    break;
                case 'refentry':
                    if ($xmlElement->ownerDocument->documentElement === $elementsWithID->item($i)) {
                        $rootID = $id;
                    } else {
                        if ($hashID === '') {
                            $hashID = $id;
                        }
                    }
                    break;
                default:
                    if ($hashID === '') {
                        $hashID = $id;
                    }
                    break;
            }
        }

        if ($result === '') {
            if ($rootID === '') {
                if ($hashID !== '') {
                    $m = null;
                    if (preg_match('/^(.+)\.([^.]+)$/', $id, $m)) {
                        $rootID = $m[1];
                    }
                }
            }
            if ($rootID !== '') {
                $result = "http://www.php.net/manual/en/{$rootID}.php";
            }
        }
        if ($result !== '' && $hashID !== '') {
            $result .= "#{$hashID}";
        }
        return $result;
    }
}

/**
 * Class that holds all the items extracted from the PHP Manual.
 */
class PHPManualItems
{

    /**
     *
     * @var PHPManualItem[]
     */
    private $items = array();

    /**
     *
     * @var array
     */
    private $lookupMap = array();

    /**
     *
     * @param string $name
     * @param int $allowedKinds
     * @return PHPManualItem|null
     */
    public function get($name, $allowedTypes)
    {
        $result = null;
        $key = strtolower($name);
        if (isset($this->lookupMap[$key])) {
            foreach ($this->lookupMap[$key] as $index) {
                $item = $this->items[$index];
                if (($item->types & $allowedTypes) !== 0) {
                    $result = $item;
                    break;
                }
            }
        }
        return $result;
    }

    /**
     *
     * @param string $name
     * @param int $allowedKinds
     * @param bool $refineType
     * @return PHPManualItem
     */
    public function getOrCreate($name, $allowedTypes, $refineType)
    {
        $result = $this->get($name, $allowedTypes);
        if ($result === null) {
            $result = $this->create($name, $allowedTypes);
        } elseif ($refineType) {
            $result->types = $result->types & $allowedTypes;
        }
        return $result;
    }

    /**
     *
     * @param string $name
     * @param int $allowedTypes
     * @return PHPManualItem
     */
    public function create($name, $types)
    {
        $item = new PHPManualItem();
        $item->types = $types;
        $this->add($name, $item);
        return $item;
    }

    /**
     *
     * @param string $name
     * @param PHPManualItem $item
     */
    public function add($name, PHPManualItem $item)
    {
        $key = strtolower($name);
        $index = count($this->items);
        $this->items[$index] = $item;
        if (! isset($this->lookupMap[$key])) {
            $this->lookupMap[$key] = array();
        }
        $this->lookupMap[$key][] = $index;
    }
}

/**
 * Class that holds data about an item extracted from the PHP Manual.
 */
class PHPManualItem
{

    /**
     * Item type: unknown
     *
     * @var int
     */
    const TYPE_UNKNOWN = 0xFFFF;

    /**
     * Item type: global constant
     *
     * @var int
     */
    const TYPE_GLOBALCONSTANT = 0x0001;

    /**
     * Item type: global variable
     *
     * @var int
     */
    const TYPE_GLOBALVARIABLE = 0x0002;

    /**
     * Item type: global function
     *
     * @var int
     */
    const TYPE_GLOBALFUNCTION = 0x0004;

    /**
     * Item type: trait
     *
     * @var int
     */
    const TYPE_TRAIT = 0x0008;

    /**
     * Item type: interface
     *
     * @var int
     */
    const TYPE_INTERFACE = 0x0010;

    /**
     * Item type: class
     *
     * @var int
     */
    const TYPE_CLASS = 0x0020;

    /**
     * Item type: class constant
     *
     * @var int
     */
    const TYPE_CLASSCONSTANT = 0x0040;

    /**
     * Item type: class property
     *
     * @var int
     */
    const TYPE_CLASSPROPERTY = 0x0080;

    /**
     * Item type: class method
     *
     * @var int
     */
    const TYPE_CLASSMETHOD = 0x0100;

    /**
     * Possible types of the item.
     *
     * @property-read
     *
     * @var int
     */
    public $types = self::TYPE_UNKNOWN;

    /**
     * URL of the item.
     *
     * @property-read
     *
     * @var string
     */
    public $url = '';

    /**
     * Description of the item.
     *
     * @property-read
     *
     * @var string
     */
    public $description = '';

    /**
     * Start of availability.
     *
     * @property-read
     *
     * @var string
     */
    public $versionFrom = '';

    /**
     * End of availability.
     *
     * @property-read
     *
     * @var string
     */
    public $versionTo = '';

    /**
     * Start of deprecation.
     *
     * @property-read
     *
     * @var string
     */
    public $versionDeprecated = '';

    /**
     * Removed since version.
     *
     * @property-read
     *
     * @var string
     */
    public $versionRemoved = '';

    /**
     * The function/method parameters.
     *
     * @var PHPManualFunctionParameter[] Keys are the parameter index, values are PHPManualFunctionParameter instances
     */
    public $functionParameters = [];

    /**
     * The function/method return type.
     *
     * @property-read
     *
     * @var string
     */
    public $functionReturnType = '';

    /**
     * The function/method return type allows returning NULL?
     *
     * @property-read
     *
     * @var bool|null
     */
    public $functionReturnTypeAllowsNull;

    /**
     * A description of the function/method result.
     *
     * @var string
     */
    public $functionReturnDescription = '';

    /**
     * Generate the PHPDoc for since/deprecated data.
     *
     * @param bool $forceDeprecated
     *
     * @return string
     */
    public function getVersionPHPDoc($forceDeprecated = false)
    {
        $lines = array();
        if ($this->versionFrom !== '') {
            $lines[] = '@since ' . $this->versionFrom;
        }
        if ($this->versionTo !== '') {
            $lines[] = '@deprecated valid to ' . $this->versionTo;
        }
        if ($this->versionRemoved !== '') {
            $lines[] = '@deprecated removed since ' . $this->versionRemoved;
        }
        if ($this->versionDeprecated !== '') {
            $lines[] = '@deprecated as of ' . $this->versionDeprecated;
        }
        if ($forceDeprecated && $this->versionTo === '' && $this->versionTo === '' && $this->versionRemoved === '' && $this->versionDeprecated === '') {
            $lines[] = '@deprecated';
        }

        return implode("\n\n", $lines);
    }
}

/**
 * Class that holds data about an item extracted from the PHP Manual.
 */
class PHPManualFunctionParameter
{

    /**
     * Name of the parameter.
     *
     * @property-read
     *
     * @var string
     */
    public $name = '';

    /**
     * Description of the parameter.
     *
     * @property-read
     *
     * @var string
     */
    public $description = '';

    /**
     * Raw type of the parameter.
     *
     * @property-read
     *
     * @var string
     */
    public $type = '';

    /**
     * The default value of the parameter.
     *
     * @property-read
     *
     * @var string
     */
    public $defaultValue = '';
}

/**
 * Holds data for functions/methods merged from XML and PHPManualItem
 */
class PHPManualMergedFunction
{

    /**
     *
     * @property-read
     *
     * @var string
     */
    public $rawReturnType;

    /**
     *
     * @property-read
     *
     * @var bool|null
     */
    public $returnTypeAllowsNull;

    /**
     *
     * @property-read
     *
     * @var PHPManualMergedFunctionParameter[]
     */
    public $parameters = [];

    /**
     *
     * @var DOMElement|$xmlFunction
     */
    private $xmlFunction;

    /**
     *
     * @var PHPManualItem|null
     */
    private $manualItem;

    public function __construct(DOMElement $xmlExtension, DOMElement $xmlFunction, DOMElement $xmlFunctionParent = null, PHPManualItem $manualItem = null)
    {
        $this->xmlFunction = $xmlFunction;
        $this->manualItem = $manualItem;
        $this->rawReturnType = $xmlFunction->getAttribute('returnType');
        if ($this->rawReturnType === '' && $manualItem !== null) {
            $this->rawReturnType = $manualItem->functionReturnType;
        }
        switch ($xmlExtension->getAttribute('returnTypeAllowsNull')) {
            case 'true':
                $this->returnTypeAllowsNull = true;
                break;
            case 'false':
                $this->returnTypeAllowsNull = false;
                break;
            case '':
                $this->returnTypeAllowsNull = $manualItem !== null ? $manualItem->functionReturnTypeAllowsNull : null;
        }
        $parameterIndex = 0;
        foreach ($xmlFunction->childNodes as $childNode) {
            if ($childNode->nodeType === XML_ELEMENT_NODE && $childNode->localName === 'parameter') {
                $parameterItem = $manualItem !== null && isset($manualItem->functionParameters[$parameterIndex]) ? $manualItem->functionParameters[$parameterIndex] : null;
                $this->parameters[] = new PHPManualMergedFunctionParameter($childNode, $parameterItem);
                $parameterIndex ++;
            }
        }
    }

    public function getParametersPHPDoc($currentNamespace, TypeFormatter $typeFormatter)
    {
        $result = array();
        foreach ($this->parameters as $parameter) {
            $result[] = $parameter->renderAsPHPDoc($currentNamespace, $typeFormatter);
        }
        return implode("\n", $result);
    }

    public function getVersionPHPDoc()
    {
        $forceDeprecated = $this->xmlFunction->getAttribute('deprecated') === 'true';
        if ($this->manualItem === null) {
            $result = $forceDeprecated ? '@deprecated' : '';
        } else {
            $result = $this->manualItem->getVersionPHPDoc($forceDeprecated);
        }
        return $result;
    }
}

class PHPManualMergedFunctionParameter
{

    /**
     * The parameter name (without the leading '$')
     *
     * @property-read
     *
     * @var string
     */
    public $name;

    /**
     * The parameter description.
     *
     * @property-read
     *
     * @var string
     */
    public $description;

    /**
     * The raw parameter type.
     *
     * @property-read
     *
     * @var string
     */
    public $rawType;

    /**
     * Is the parameter passed by reference?
     *
     * @property-read
     *
     * @var bool
     */
    public $byReference;

    /**
     * Is the parameter variadic?
     *
     * @property-read
     *
     * @var bool
     */
    public $variadic;

    /**
     * Is this parameter optional?
     *
     * @var bool
     */
    public $isOptional;

    /**
     * The default parameter value (set if the parameter is optional).
     *
     * @property-read
     *
     * @var string
     */
    public $defaultValue;

    public function __construct(DOMElement $xmlParameter, PHPManualFunctionParameter $manualParameter = null)
    {
        $this->name = $manualParameter === null ? '' : $manualParameter->name;
        if ($this->name === '') {
            $this->name = $xmlParameter->getAttribute('name');
        }
        $this->description = $manualParameter === null ? '' : $manualParameter->description;
        $this->rawType = $xmlParameter->getAttribute('type');
        if ($this->rawType === '' && $manualParameter !== null) {
            $this->rawType = $manualParameter->type;
        }
        $this->byReference = $xmlParameter->getAttribute('byReference') === 'true';
        $this->variadic = $xmlParameter->getAttribute('variadic') === 'true';
        $this->defaultValue = '';
        if ($this->variadic === false) {
            // Variadic parameter cannot have a default value
            $this->isOptional = $xmlParameter->getAttribute('optional') === 'true';
            if ($manualParameter !== null && $manualParameter->defaultValue !== '') {
                $this->defaultValue = $manualParameter->defaultValue;
            } else if ($xmlParameter->getAttribute('allowsNull') === 'true') {
                $this->defaultValue = 'null';
            }
        } else {
            $this->isOptional = false;
        }
    }

    /**
     *
     * @return string
     */
    public function renderAsPHPDoc($currentNamespace, TypeFormatter $typeFormatter)
    {
        $type = $typeFormatter->format($this->rawType === '' ? 'mixed' : $this->rawType, $this->defaultValue !== '', $currentNamespace, TypeFormatter::PLACE_DOC_PARAMETER);
        $result = '@param ' . ($type === '' ? 'mixed' : $type);
        $result .= ' $' . $this->name;
        if ($this->description !== '') {
            $result .= ' ' . $this->description;
        }

        return $result;
    }

    /**
     *
     * @return string
     */
    public function renderAsPHPCode($currentNamespace, TypeFormatter $typeFormatter)
    {
        $result = '';
        $type = $typeFormatter->format($this->rawType, $this->defaultValue !== '', $currentNamespace, TypeFormatter::PLACE_CODE_PARAMETER);
        if ($type !== '') {
            $result .= $type . ' ';
        }
        if ($this->byReference) {
            $result .= '&';
        }
        if ($this->variadic) {
            $result .= '...';
        }
        $result .= '$' . $this->name;
        if ($this->defaultValue !== '') {
            $result .= ' = ';
            if (strpos($this->defaultValue, '(') === false) {
                $result .= $this->defaultValue;
            } else {
                $result .= "/* {$this->defaultValue} */ null";
            }
        } elseif ($this->isOptional) {
            $result .= ' = null';
        }
        return $result;
    }
}

/**
 * Helper class to be used to cache data read from the PHP manual.
 */
class PHPManualCache
{

    /**
     * Cache for the document ID map.
     *
     * @var string
     */
    const KEY_DOCUMENTIDMAP = 'idmap';

    /**
     * Cache for the XML entities.
     *
     * @var string
     */
    const KEY_XMLENTITIES = 'entities';

    /**
     * Cache for the manual items.
     *
     * @var string
     */
    const KEY_ITEMS = 'items';

    /**
     * Specify any KEY.
     *
     * @var string
     */
    const ANYKEY = 'all';

    /**
     * Should we persist cache data?
     *
     * @var bool
     */
    private $persistent;

    /**
     * Where to persist the cache data.
     *
     * @var bool
     */
    private $filename;

    /**
     * The keys of the cache items to be rebuilt.
     *
     * @var string[]
     */
    private $rebuildCacheItems;

    /**
     * The data cached to memory.
     *
     * @var array|null
     */
    private $data;

    /**
     * Initialize the instance.
     *
     * @param bool $persistent
     *            Should we persist cache data?
     * @param string $filename
     *            Where to persist the cache data.
     * @param string[] $rebuildCacheItems
     *            The keys of the cache items to be rebuilt
     */
    public function __construct($persistent, $filename = '', array $rebuildCacheItems = array())
    {
        $this->persistent = (bool) $persistent;
        $this->filename = (string) $filename;
        $this->rebuildCacheItems = $rebuildCacheItems;
    }

    /**
     * Get the default cache file name.
     *
     * @return string
     */
    public static function getDefaultCacheFile()
    {
        return str_replace('/', DIRECTORY_SEPARATOR, __FILE__) . '.cache';
    }

    /**
     * Initialize (if needed) the $data property.
     */
    private function initializeData()
    {
        if ($this->data === null) {
            $data = null;
            if ($this->persistent && ! in_array(self::ANYKEY, $this->rebuildCacheItems, true)) {
                if (is_file($this->filename)) {
                    $data = @unserialize(@base64_decode(@file_get_contents($this->filename)));
                    if (is_array($data)) {
                        foreach ($this->rebuildCacheItems as $cacheItemKey) {
                            unset($data[$cacheItemKey]);
                        }
                    } else {
                        $data = null;
                    }
                }
            }
            $this->data = $data === null ? array() : $data;
        }
    }

    /**
     * Get an item from the cache.
     *
     * @param string $key
     *
     * @return mixed|null
     */
    public function get($key)
    {
        $this->initializeData();
        return isset($this->data[$key]) ? $this->data[$key] : null;
    }

    /**
     * Does the cache contain a specific key?
     *
     * @param string $key
     *
     * @return bool
     */
    public function has($key)
    {
        $this->initializeData();
        return array_key_exists($key, $this->data);
    }

    /**
     * Get an item from the cache.
     *
     * @param string $key
     * @param mixed $value
     */
    public function set($key, $value)
    {
        $this->initializeData();
        $this->data[$key] = $value;
        if ($this->persistent) {
            file_put_contents($this->filename, base64_encode(serialize($this->data)));
        }
    }
}

/**
 * Helper class to format types
 */
class TypeFormatter
{

    /**
     * Place where the formatted type should be placed: PHPDoc for function/method parameter.
     *
     * @var int
     */
    const PLACE_DOC_PARAMETER = 1;

    /**
     * Place where the formatted type should be placed: PHPDoc for function/method return type.
     *
     * @var int
     */
    const PLACE_DOC_RETURNTYPE = 2;

    /**
     * Place where the formatted type should be placed: PHP code for function/method parameter.
     *
     * @var int
     */
    const PLACE_CODE_PARAMETER = 3;

    /**
     * Place where the formatted type should be placed: PHP code for function/method return type.
     *
     * @var int
     */
    const PLACE_CODE_RETURNTYPE = 4;

    /**
     * The PHP version identifier (example: 720 for PHP 7.2)
     *
     * @var int
     */
    private $phpVersionId;

    /**
     * Aliases of primitive types.
     *
     * @var array
     */
    private $primitiveAliases = array(
        'boolean' => 'bool',
        'callback' => 'callable',
        'double' => 'float',
        'integer' => 'int',
        'number' => 'float',
        'numeric' => 'float'
    );

    /**
     * Initialize the instance.
     *
     * @param string $phpVersion
     */
    public function __construct($phpVersion)
    {
        $m = null;
        preg_match('/^(\d+)\.(\d+)/', $phpVersion, $m);
        $this->phpVersionId = (int) $m[1] * 100 + (int) $m[2];
    }

    /**
     * Format a raw type .
     *
     * @param string $type
     *            The raw type to be formatted.
     * @param bool $allowsNull
     *            Can the type be null?
     * @param string $currentNamespace
     *            The current namespace
     * @param int $place
     *            Where the output will be placed? (One of the TypeFormatter::PLACE_... constants)
     *            
     * @return string
     */
    public function format($type, $allowsNull, $currentNamespace, $place)
    {
        $result = '';
        $type = (string) $type;
        if ($type !== '' && $type !== '|' && $type !== '?' && $type !== '[]') {
            $chunks = explode('|', $type);
            if (count($chunks) > 1) {
                switch ($place) {
                    case self::PLACE_DOC_PARAMETER:
                    case self::PLACE_DOC_PARAMETER:
                        $parts = array();
                        foreach ($chunks as $chunk) {
                            $parts = array_merge($parts, explode('|', $this->format($chunk, $allowsNull, $currentNamespace, $place)));
                        }
                        $parts = array_unique($parts);
                        $result = implode('|', $parts);
                        break;
                }
            } else {
                if ($type[0] === '?') {
                    $allowsNull = true;
                    $type = substr($type, 1);
                }
                if (substr($type, - 2) === '[]') {
                    $arrayOf = substr($type, 0, - 2);
                    if ($arrayOf === 'array') {
                        $arrayOf = '';
                    }
                    $type = 'array';
                } else {
                    $arrayOf = '';
                }
                if (isset($this->primitiveAliases[$type])) {
                    $type = $this->primitiveAliases[$type];
                }
                switch ($type) {
                    case 'resource':
                        switch ($place) {
                            case self::PLACE_DOC_PARAMETER:
                            case self::PLACE_DOC_RETURNTYPE:
                                $result = $allowsNull ? "$type|null" : $type;
                                break;
                        }
                        break;
                    case 'array':
                        switch ($place) {
                            case self::PLACE_DOC_PARAMETER:
                            case self::PLACE_DOC_RETURNTYPE:
                                if ($arrayOf === '') {
                                    $result = $allowsNull ? "$type|null" : $type;
                                } else {
                                    $result = $allowsNull ? "{$arrayOf}[]|null" : "{$arrayOf}[]";
                                }
                                break;
                            case self::PLACE_CODE_PARAMETER:
                                if ($this->phpVersionId >= 501) {
                                    $result = $type;
                                }
                                break;
                            case self::PLACE_CODE_RETURNTYPE:
                                if ($this->phpVersionId >= 700) {
                                    if ($allowsNull) {
                                        if ($this->phpVersionId >= 701) {
                                            $result = "?$type";
                                        }
                                    } else {
                                        $result = $type;
                                    }
                                }
                                break;
                        }
                        break;
                    case 'bool':
                    case 'float':
                    case 'int':
                    case 'string':
                        switch ($place) {
                            case self::PLACE_DOC_PARAMETER:
                            case self::PLACE_DOC_RETURNTYPE:
                                $result = $allowsNull ? "$type|null" : $type;
                                break;
                            case self::PLACE_CODE_PARAMETER:
                                if ($this->phpVersionId >= 700) {
                                    $result = $type;
                                }
                                break;
                            case self::PLACE_CODE_RETURNTYPE:
                                if ($this->phpVersionId >= 700) {
                                    if ($allowsNull) {
                                        if ($this->phpVersionId >= 701) {
                                            $result = "?$type";
                                        }
                                    } else {
                                        $result = $type;
                                    }
                                }
                                break;
                        }
                        break;
                    case 'callable':
                        if ($this->phpVersionId < 504) {
                            switch ($place) {
                                case self::PLACE_DOC_PARAMETER:
                                case self::PLACE_DOC_RETURNTYPE:
                                    $result = $allowsNull ? 'mixed|null' : 'mixed';
                                    break;
                            }
                        } else {
                            switch ($place) {
                                case self::PLACE_DOC_PARAMETER:
                                case self::PLACE_DOC_RETURNTYPE:
                                    $result = $allowsNull ? "$type|null" : $type;
                                    break;
                                case self::PLACE_CODE_PARAMETER:
                                    $result = $type;
                                    break;
                                case self::PLACE_CODE_RETURNTYPE:
                                    if ($this->phpVersionId >= 700) {
                                        if ($allowsNull) {
                                            if ($this->phpVersionId >= 701) {
                                                $result = "?$type";
                                            }
                                        } else {
                                            $result = $type;
                                        }
                                    }
                                    break;
                            }
                        }
                        break;
                    case 'iterable':
                        if ($this->phpVersionId < 701) {
                            switch ($place) {
                                case self::PLACE_DOC_PARAMETER:
                                case self::PLACE_DOC_RETURNTYPE:
                                    $result = $allowsNull ? 'mixed|null' : 'mixed';
                                    break;
                            }
                        } else {
                            switch ($place) {
                                case self::PLACE_DOC_PARAMETER:
                                case self::PLACE_DOC_RETURNTYPE:
                                    $result = $allowsNull ? "$type|null" : $type;
                                    break;
                                case self::PLACE_CODE_PARAMETER:
                                    $result = $type;
                                    break;
                                case self::PLACE_CODE_RETURNTYPE:
                                    $result = $allowsNull ? "?$type" : $type;
                                    break;
                            }
                        }
                        break;
                    case 'object':
                        if ($this->phpVersionId < 702) {
                            switch ($place) {
                                case self::PLACE_DOC_PARAMETER:
                                case self::PLACE_DOC_RETURNTYPE:
                                    $result = $allowsNull ? 'mixed|null' : 'mixed';
                                    break;
                            }
                        } else {
                            switch ($place) {
                                case self::PLACE_DOC_PARAMETER:
                                case self::PLACE_DOC_RETURNTYPE:
                                    $result = $allowsNull ? "$type|null" : $type;
                                    break;
                                case self::PLACE_CODE_PARAMETER:
                                    $result = $type;
                                    break;
                                case self::PLACE_CODE_RETURNTYPE:
                                    $result = $allowsNull ? "?$type" : $type;
                                    break;
                            }
                        }
                        break;
                    case 'self':
                        switch ($place) {
                            case self::PLACE_DOC_PARAMETER:
                            case self::PLACE_DOC_RETURNTYPE:
                                $result = $allowsNull ? "$type|null" : $type;
                                break;
                            case self::PLACE_CODE_PARAMETER:
                                $result = $type;
                                break;
                            case self::PLACE_CODE_RETURNTYPE:
                                if ($this->phpVersionId >= 700) {
                                    if ($allowsNull) {
                                        if ($this->phpVersionId >= 701) {
                                            $result = "?$type";
                                        }
                                    } else {
                                        $result = $type;
                                    }
                                }
                                break;
                        }
                        break;
                    case 'void':
                        switch ($place) {
                            case self::PLACE_DOC_PARAMETER:
                                $result = $allowsNull ? 'mixed|null' : 'mixed';
                                break;
                            case self::PLACE_DOC_RETURNTYPE:
                                $result = $allowsNull ? "$type|null" : $type;
                                break;
                            case self::PLACE_CODE_RETURNTYPE:
                                if ($this->phpVersionId >= 701) {
                                    $result = $allowsNull ? "?$type" : $type;
                                }
                                break;
                        }
                        break;
                    case 'scalar':
                    case 'mixed':
                        switch ($place) {
                            case self::PLACE_DOC_PARAMETER:
                            case self::PLACE_DOC_RETURNTYPE:
                                $result = $allowsNull ? 'mixed|null' : 'mixed';
                                break;
                        }
                        break;
                    default:
                        $fqType = $currentNamespace === '' ? $type : "\\$type";
                        switch ($place) {
                            case self::PLACE_DOC_PARAMETER:
                            case self::PLACE_DOC_RETURNTYPE:
                                $result = $allowsNull ? "$fqType|null" : $fqType;
                                break;
                            case self::PLACE_CODE_PARAMETER:
                                $result = $fqType;
                                break;
                            case self::PLACE_CODE_RETURNTYPE:
                                if ($this->phpVersionId >= 700) {
                                    if ($allowsNull) {
                                        if ($this->phpVersionId >= 701) {
                                            $result = "?$fqType";
                                        }
                                    } else {
                                        $result = $fqType;
                                    }
                                }
                                break;
                        }
                        break;
                }
            }
        }
        return $result;
    }
}

/**
 * Helper class to be used to write a stub file.
 */
class StubWriter
{

    /**
     * The character sequence to be used for every indentation level.
     *
     * @var string
     */
    const INDENTATION_STRING = '    ';

    /**
     * The name of the file being written.
     *
     * @var string
     */
    private $filename;

    /**
     * The handle of the file being written.
     *
     * @var resource
     */
    private $fd;

    /**
     * The current indentation level.
     *
     * @var int
     */
    private $indentationLevel = 0;

    /**
     * Are we in a namespace? 0: no, 1: yes (single namespace), 2: yes (multiple namespaces).
     *
     * @var int
     */
    private $inNamespace = 0;

    /**
     * Are we currently writing a PHPDoc?
     *
     * @var bool
     */
    private $inPHPDoc = false;

    /**
     * Initialize the instance.
     *
     * @param string $filename
     */
    public function __construct($filename)
    {
        $this->filename = $filename;
        $this->fd = fopen($this->filename, 'wb');
        $this->writeln('<?php');
    }

    /**
     * Increase the indentation level.
     */
    public function increaseIndentation()
    {
        $this->indentationLevel ++;
    }

    /**
     * Decrease the indentation level.
     *
     * @throws Exception
     */
    public function decreaseIndentation()
    {
        if ($this->indentationLevel < 1) {
            throw new Exception('Unable to decrease indentation');
        }
        $this->indentationLevel --;
    }

    /**
     * Deinitialize the instance.
     */
    public function __destruct()
    {
        if ($this->fd) {
            @fclose($this->fd);
            $this->fd = null;
        }
    }

    /**
     * Delete the stub file.
     */
    public function delete()
    {
        if ($this->fd) {
            @fclose($this->fd);
            $this->fd = null;
            @unlink($this->filename);
        }
    }

    /**
     * Output a string to the currently open file.
     *
     * @param string $string
     */
    private function write($string)
    {
        fwrite($this->fd, $string);
    }

    /**
     * Output a line to the currently open file, fixing indentation and adding comments if we are writing a PHPDoc.
     *
     * @param string $string
     */
    public function writeln($string = '')
    {
        $indent = $this->indentationLevel === 0 ? '' : str_repeat(self::INDENTATION_STRING, $this->indentationLevel);
        $lines = explode("\n", $string);
        foreach ($lines as $line) {
            if ($line === '') {
                $this->write($this->inPHPDoc ? "{$indent} *\n" : "\n");
            } else {
                $this->write($indent . ($this->inPHPDoc ? ' * ' : '') . $line . "\n");
            }
        }
    }

    /**
     * Start a namespace.
     *
     * @param string $name
     *            The namespace name.
     * @param bool $singleNamespace
     *            Is this the only namespace for the whole file?
     */
    public function startNamespace($name, $singleNamespace)
    {
        if ($this->inNamespace !== 0) {
            throw new Exception('Namespace already started');
        }
        if ($singleNamespace) {
            $this->inNamespace = 1;
            if ($name !== '') {
                $this->writeln();
                $this->writeln("namespace {$name};");
                $this->writeln();
            }
        } else {
            $this->inNamespace = 2;
            $this->writeln();
            $this->writeln('namespace' . ($name === '' ? '' : " $name") . ' {');
            $this->increaseIndentation();
        }
    }

    /**
     * End the current namespace.
     */
    public function endNamespace()
    {
        if ($this->inNamespace === 0) {
            throw new Exception('Namespace not started');
        }
        if ($this->inNamespace === 2) {
            $this->decreaseIndentation();
            $this->writeln('}');
        }
        $this->inNamespace = 0;
    }

    /**
     * Start a PHPDoc chunk.
     *
     * @throws Exception
     */
    public function startPHPDoc()
    {
        if ($this->inPHPDoc) {
            throw new Exception('PHPDoc already started');
        }
        $this->writeln('/**');
        $this->inPHPDoc = true;
    }

    /**
     * Terminate a PHPDoc chunk.
     *
     * @throws Exception
     */
    public function stopPHPDoc()
    {
        if (! $this->inPHPDoc) {
            throw new Exception('PHPDoc not started');
        }
        $this->inPHPDoc = false;
        $this->writeln(' */');
    }

    public function writePHPDocParts(array $parts)
    {
        $first = true;
        foreach ($parts as $part) {
            if ($part !== '') {
                if ($first) {
                    $this->startPHPDoc();
                    $first = false;
                } else {
                    $this->writeln();
                }
                $this->writeln($part);
            }
        }
        if ($first === false) {
            $this->stopPHPDoc();
        }
    }
}

trait VerboseTrait
{

    /**
     * Verbose output?
     *
     * @var bool
     */
    private $verbose = false;

    /**
     * Print a line (if verbose is enabled).
     *
     * @param string $what
     */
    private function say($what)
    {
        if ($this->verbose) {
            echo $what, "\n";
        }
    }
}

class UserMessageException extends Exception
{
}

/**
 * Wrapper class for DOMXPath
 */
class MyDOMXPath
{

    /**
     *
     * @var DOMXPath
     */
    private $xPath;

    /**
     * Initialize the instance.
     *
     * @param DOMDocument $document
     * @param string $namespace
     */
    public function __construct(DOMDocument $document, $namespace)
    {
        $this->xPath = new DOMXPath($document);
        $this->xPath->registerNamespace('ns', $namespace);
    }

    /**
     * Evaluates the given XPath expression.
     *
     * @param string $expression
     * @param DOMNode $contextNode
     * @return DOMNodeList|DOMNode[]
     */
    public function query($expression, DOMNode $contextNode = null)
    {
        return $this->xPath->query($expression, $contextNode);
    }

    /**
     * Evaluates the given XPath expression.
     *
     * @param string $expression
     * @param DOMNode $contextNode
     * @return DOMElement|null
     */
    public function queryFirstElement($expression, DOMNode $contextNode = null)
    {
        $result = null;
        $list = $this->query($expression, $contextNode);
        if ($list->length > 0) {
            $item = $list->item(0);
            if ($item->nodeType === XML_ELEMENT_NODE) {
                $result = $item;
            }
        }

        return $result;
    }
}

$error = null;
try {
    $generator = new StubsGenerator($_SERVER['argv']);
    $generator->prefetch();
    $generator->process();
} catch (Throwable $x) {
    $error = $x;
} catch (Exception $x) {
    $error = $x;
}
if ($error !== null) {
    fwrite(STDERR, $error->getMessage() . "\n");
    if (! $error instanceof UserMessageException) {
        fwrite(STDERR, 'Line: ' . $error->getLine() . "\n");
    }
    exit(1);
}
exit(0);
